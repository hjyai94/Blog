---
title: 算法学习一
date: 2019-04-27 20:50:49
tags: 算法
categories: 学习
---
最近写论文写不动，然后又不知道干点啥来荒废时间，正好看到了一本挺有意思的算法书《我的第一本算法书》，准备读一读，结合一些开源的程序，学习一下，并实现一下。本文的主要内容来自于《我的第一本算法书》和维基百科。

# 算法的时间复杂度
算法的时间复杂度通常用 $O$ 符号来表示，它的意思是忽略重要项以外的内容，比如说 $O(n^2)$ 表示算法的运行时间最长为 $n^2$ 的常数倍。
1. 如果链表中的数据量为 $n$，我们从链表头部线性查找，如果目标在链表最后，需要的时间为 $o(n)$。链表中添加数据只需要更改两个指针的指向，所以耗费的时间与 $n$ 无关。如果到达了添加(删除)数据的位置，那么添加(删除)只需要 $O(1)$ 的时间。
2. 数组与链表不同，数据是通过下表确定内存地址的，所以访问 $n$ 个数据的某个数据仅为恒定的 $O(1)$ 时间。若向数组中添加数据，则需要将目标位置的数据之后的数据一个个移开，如果在头部添加数据则需要 $O(n)$ 时间，删除同理。
3. 在哈希表中，可以采用哈希函数快速访问到数组中的目标数据，如果发生哈希冲突，我们就使用链表进行存储。
4. 在堆中，假设有 $n$ 个节点，根据堆的特点我们可以知道堆的高度为 $log_2\ n$ (类似于等比数列求和)，那么对堆进行排序时间复杂度为 $O(log\ n)$。
5. 二叉搜索树的比较次数取决于树的高度，如果节点为 $n$，树的的形状又较为均衡的话，比较的大小和移动的次数最多为 $log_2\ n$， 因此时间复杂度为 $O(log\ n)$。

# 排序
所谓排序就是讲数据按照升序的方式调整顺寻，下面将介绍几种常见的排序算法。

## 冒泡排序
冒泡算法重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。冒泡排序对 $n$ 个数据的排序的时间复杂度 $O(n^2)$ 。
```
def bubble_sorted(iterable):
    new_list = list(iterable)
    list_len = len(new_list)
    for i in range(list_len - 1):
        for j in range(list_len - 1, i, -1):
            if new_list[j] < new_list[j - 1]:
                new_list[j], new_list[j - 1] = new_list[j - 1], new_list[j]
    return new_list
    
testlist = [27, 33, 28, 4, 2, 26, 13, 35, 8, 14]
print('sorted:', bubble_sorted(testlist))
```

## 选择排序
选择排序是一种简单直接的排序算法。它的工作原理如下：首先找到未排序列中最小的元素，存放在
排序序列的其实位置，然后再从剩余未排序元素中寻找最小元素，然后放到一排序序列的末尾，一次类推，知道所有元素排序完毕。![]()
```
def selection_sort(arr):
    for i in range(len(arr)):
        minIndex=i
        for j in range(i+1,len(arr)):
            if arr[minIndex]>arr[j]:
                minIndex=j
        if i==minIndex:
            pass
        else:
            arr[i],arr[minIndex]=arr[minIndex],arr[i]
    return arr
if __name__ == '__main__':
    testlist = [17, 23, 20, 14, 12, 25, 1, 20, 81, 14, 11, 12]
    print(selection_sort(testlist))
```